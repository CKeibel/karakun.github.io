---
layout: post
title:  'How one request can kill your company'
author: hendrik
featuredImage: exploit
excerpt: 'As developers we always try to create bugfree and secure applications .Sometimes the most critical issues are not part of our code but of its dependencies. This post shows how
security issues in dependencies can be used to create horrible attack scenarios of your systems. I will show one exploit in a simply Java based server application that can be used to do
mostly everything with your whole system.'
categories: [Java, OpenJDK]
header:
  text: TODO
  image: post
---
Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.

![Security duke]({{ "/assets/posts/2019-01-25-security-exploits/security-duke.png" | absolute_url }})

Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.

## Creating a small server application

To give you an example of a security issue and an exploit that will use this issue to do really bad things I will create a minimalistic server application in Java.
The application should handle some data items and should provide a http endpoint by that a client can receive the current item set and mutate the data.

To create such application you can choose between several Java based framework like Spring (Boot) or JakartaEE. In this concrete sample I decieded to use one of the smallest
frameworks that I know for such usecase. By using [spark](http://sparkjava.com) I can easily define a small http server in just 1 Java class. To make my life easier I will
add [jackson](https://github.com/FasterXML/jackson) and [xalan](https://xalan.apache.org) as additional dependencies to provide automatic JSON-Object-Mapping for my application. 
Since I decided to use Maven for such small example the `pom.xml` file might look like this:

{% highlight xml %}
<project>
    <groupId>com.karakun.dev</groupId>
    <artifactId>exploit</artifactId>
    <version>1.0-SNAPSHOT</version>

    <dependencies>
        <dependency>
            <groupId>com.sparkjava</groupId>
            <artifactId>spark-core</artifactId>
            <version>2.7.2</version>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>2.8.8</version>
        </dependency>
        <dependency>
            <groupId>xalan</groupId>
            <artifactId>xalan</artifactId>
            <version>2.7.2</version>
        </dependency>
    </dependencies>
</project>
{% endhighlight %}

As you can see in the maven definition our application will only need 3 dependencies. If you have a deeper look you will see that we already depend on **23** libraries. 
The 3 dependencies that are defined in the pom file depend on several other libraries. All this dependencies are transitive dependencies for our application and will 
be added to the classpath. The following graph shows all libraries from that our little application depends based on the given pom:

![Dependency graph]({{ "/assets/posts/2019-01-25-security-exploits/dependency-graph.png" | absolute_url }})

The most dependencies in the graph are transitive depencies from spark. Even if this library is one of the smallest http server libs you can find it already brings a lot of things with it.
For our small application this much more than we need since we do not want to add security, use websockets or code against the servlet API. This should not be any blame against spark. I just want to show you here that your applications often depend on much more things than you might know ;)  

Let's start to code our example. The first thing that we want to define is a plain POJO. I decided to call it "Product" and defined it as a small Java bean with some properties / fields. 
As you can see in the following definition of the class there is absolutelly no magic in this code. I even do not defined `toString()`, `equals()` or `hashcode()` (which could be done but do not change anything in the sample). This "Product" data type will be the only data that our application can handle. Here is the complete code of the `Product` class:

{% highlight java %}
public class Product {

    private String name;

    private Object data;

    public Product() {
    }

    public Product(final String name, final Object data) {
        this.name = name;
        this.data = data;
    }

    public String getName() {
        return name;
    }

    public void setName(final String name) {
        this.name = name;
    }

    public Object getData() {
        return data;
    }

    public void setData(final Object data) {
        this.data = data;
    }
}
{% endhighlight %}

In our small application we want to manage such products. Instead of using a dtabase and maybe JPA (as most of us would do for real application)
I just choosed the most easy way to manage such data: a Java `List`. By defining and managing such collection in our application we can easily hold 
a list of products in memory and work with them at runtime. Since several clients might access our sever I decided to use a `CopyOnWriteArrayList` as
concrete list type in my application. by doing so we won't end in any `ConcurrentModificationException`. The follwoing code snippet shows how easy such
collection with some initial data can be created:

{% highlight java %}
final List<Product> database = new CopyOnWriteArrayList<>();
database.add(new Product("car", randomData()));
database.add(new Product("boat", randomData()));
database.add(new Product("plane", randomData()));
{% endhighlight %}

The `randomData()` method that is used in this snippet creates some random metadata for the `Product` instances. You will see the code
of this method later. For our small example this few lines of code are really everything that we need as a small in memory data store. By
using the list we can easily add a new product to our "database" or return the complete content.

As a next step we will use spark to provide http / rest endpoints for exactly this functionallity. We want to define an endpoint that can be
reached by a `GET` request to return all our products and a second endpoint that can be reached by a `POST` request. This endpoint will add a new
product that is defined in the body of the http request to our database.

![HTTP endpoints]({{ "/assets/posts/2019-01-25-security-exploits/get-post.png" | absolute_url }})

The following code snippet shows in a simplyfied form how this can be achived by using spark:

{% highlight java %}
//Configure HTTP server
Spark.port(8888);

//Define endpoints
Spark.get("/products", (request, response) -> serializer.writeValueAsString(database));
Spark.post("/products", (request, response) -> database.add(deserializer.readValue(request.body(), Product.class)));
{% endhighlight %}

For sure the post lambda needs null checks and exception handling. Next to this the `serializer` and `deserializer` objects that are used in the snippet are instances 
of the `ObjectMapper` class from jackson. This objects will be used to transform the JSON of the http requests and resonses to Java objects. Let's put the database and server 
code together in a single Java class. As you can see in the following code you can easily create such simple server with abou 50 lines of code:

{% highlight java %}
public class MyServer {

    private static final List<Product> database = new CopyOnWriteArrayList<>();

    private static final ObjectMapper deserializer = new ObjectMapper().enableDefaultTyping();
    private static final ObjectMapper serializer = new ObjectMapper();

    public static void main(String[] args) {

        //Adding some basic data
        database.add(new Product("car", randomData()));
        database.add(new Product("boat", randomData()));
        database.add(new Product("plane", randomData()));

        //Configure HTTP server
        Spark.port(8888);

        //Define endpoints
        Spark.get("/products", (request, response) -> {
            return serializer.writeValueAsString(database);
        });

        Spark.post("/products", (request, response) -> {
            try {
                final Product product = deserializer.readValue(request.body(), Product.class);
                Optional.ofNullable(product).ifPresent(p -> database.add(p));
                return "THANKS";
            } catch (final Exception e) {
                return "ERROR";
            }
        });
    }

    private static Map<String, String> randomData() {
        final String[] colors = {"yellow", "red", "green"};
        final Map<String, String> data = new HashMap<>();
        data.put("cost", new Random().nextInt(100_000) + "");
        data.put("color", colors[new Random().nextInt(colors.length)]);
        return data;
    }
}
{% endhighlight %}

At this point we can start our server and call the defined enpoints. To do such calls you can use any tool that provides
the functionallity to execute HTTP requests. I use [PAW](https://paw.cloud) on my Mac but you can use any other tool
like [curl](https://curl.haxx.se) or [postman](https://www.getpostman.com) for example.

The following snippet shows the raw content of a http get request to receive the product list from the server

{% highlight java %}
GET /products HTTP/1.1
Host: localhost:8888
Connection: close
User-Agent: Paw/3.1.7 (Macintosh; OS X/10.14.2) GCDHTTPRequest
{% endhighlight %}

When doing the request you will receive a response that contains the product list in JSON format as you can see in the following screenshot of Paw:

![Paw screen]({{ "/assets/posts/2019-01-25-security-exploits/paw.png" | absolute_url }})

Once you added a new product by doing a `POST` http request you see the new product in this JSON list when doing a new `GET` request. For posting a 
a new product the body of your http requests needs to look like this:

{% highlight json %}
{
  "name":"jetpack",
  "data":["java.util.HashMap",{"cost":"200_000","color":"yellow"}]
}
{% endhighlight %}

Thanks to the jackson and xalan dependency our server application will automatically create a new `Product` instance from the given JSON definition.

## Let's hack